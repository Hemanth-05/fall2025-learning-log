# Date: 2025-09-02

## Topics Covered: Synchronous vs Asynchronous Programming & The Event Loop, Async fs Module, Promise

Understanding the difference between synchronous and asynchronous programming is key to mastering Node.js.  
The event loop is what makes asynchronous programming possible in JavaScript.

---

### üîπ 1. Synchronous vs Asynchronous Programming

#### ‚úÖ Synchronous (Blocking)
- Code runs one line at a time, in order.  
- Each operation must finish before the next one starts.  
- If one operation is slow (e.g., file read, DB query), everything else waits.

**Example:**
```js
const fs = require('fs');

// Blocking (synchronous)
const data = fs.readFileSync('file.txt', 'utf8');
console.log("File content:", data);

console.log("This runs AFTER file is read");
```

---

#### ‚úÖ Asynchronous (Non-Blocking)
- Operations hand off the work to the OS/libuv.  
- The JS thread continues running other code.  
- When the work finishes, a callback/promise notifies your code.

**Example:**
```js
const fs = require('fs');

// Non-blocking (asynchronous)
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log("File content:", data);
});

console.log("This runs IMMEDIATELY");
```

---

### üîπ 2. The Event Loop
Node.js uses an **event loop** to manage asynchronous operations.  
Think of it like a waiter in a restaurant:

- **Synchronous model**: the waiter takes an order and stands idle until food is ready (blocking).  
- **Asynchronous model**: the waiter takes an order, the chef cooks in the background, and the waiter keeps serving other tables.  

When the food is ready, the waiter gets notified and delivers it.  
That ‚Äúnotification‚Äù in Node.js is a **callback** (or promise resolution).

---

### üîπ 3. Call Stack and Callback Queue

- The **call stack** holds functions currently running (execution contexts).  
- Works in **LIFO order**: push function when called, pop when finished.  
- Async operations (e.g., `setTimeout`, `fs.readFile`) hand work to **libuv/OS**, and their callbacks wait in the **callback queue**.  
- The **event loop** checks if the stack is empty, then pushes callbacks from the queue onto the stack to run.

‚ö° **Important:** Even though the stack empties after each function finishes, the event loop does **NOT** run queued callbacks at those micro-gaps.  
It executes **all synchronous code first, top-to-bottom**, before checking the callback queue.

---

### üîπ 4. Example Timeline

```js
console.log("Start");

setTimeout(() => console.log("Timeout callback"), 0);

console.log("End");
```

**Output:**
```
Start
End
Timeout callback
```

**Explanation:**
1. `"Start"` is printed.  
2. `setTimeout` registers the callback in background.  
3. `"End"` is printed.  
4. Only **after all synchronous code is finished**, the event loop runs the callback.

---

### ‚úÖ Summary
- **Synchronous = blocking**, one task at a time.  
- **Asynchronous = non-blocking**, tasks handled in background and callbacks queued.  
- The **event loop** manages callbacks/promises.  
- **All synchronous code executes first before any async callbacks**.  


---

### üîπ 5. Example with setTimeout and Order of Execution

```js
console.log("1");
console.log("2");

setTimeout(() => console.log("3"), 0);

console.log("4");
console.log("5");
```

**Observed Output:**
```
1
2
4
5
3
```

#### Step-by-Step Timeline
1. `console.log("1")` ‚Üí runs immediately ‚Üí prints `1`.  
2. `console.log("2")` ‚Üí runs immediately ‚Üí prints `2`.  
3. `setTimeout(..., 0)` ‚Üí callback (`console.log("3")`) handed to libuv (background).  
   - It will be queued when the timer expires.  
   - **Important:** the callback is NOT executed now.  
4. `console.log("4")` ‚Üí prints `4`.  
5. `console.log("5")` ‚Üí prints `5`.  
6. Now all synchronous code has finished, the call stack is empty.  
7. Event loop takes the queued callback and executes it ‚Üí prints `3`.  

### Key Point
‚ö° Even though the call stack becomes empty after each function, the event loop does **not** sneak in async callbacks immediately.  
It waits until **all synchronous code in the current run finishes**, then executes callbacks from the queue.

---

### Async fs Module
- Refer to the async.js file in the practice folder. When we use Node.js callback-style async programming, we don‚Äôt need try...catch around the async call itself, because errors are delivered as the first argument to the callback.
However, try...catch is still useful inside the callback for sync code, and it‚Äôs required again when using async/await

### Promise

#### üì¶ Promises in JavaScript (Easy Explanation)

A **Promise** is like a **placeholder for a value that you don‚Äôt have yet, but will get in the future**.  

Think of it as a ‚Äú**to-be-delivered box**‚Äù:  
- Right now it‚Äôs empty.  
- Later, it will either get filled with your item (success ‚úÖ) or with an error note (failure ‚ùå).  

---

##### üîπ The 3 States of a Promise
1. **Pending** ‚Üí waiting, not finished yet.  
2. **Fulfilled (Resolved)** ‚Üí completed successfully, you get a value.  
3. **Rejected** ‚Üí failed, you get an error.  

---

##### üîπ Real Life Analogy
Imagine you order food online:  
- You place the order ‚Üí Promise is **pending**.  
- Food arrives ‚Üí Promise is **fulfilled** (resolved).  
- Restaurant cancels order ‚Üí Promise is **rejected**.  

---

##### üîπ Creating a Promise
```js
const orderFood = new Promise((resolve, reject) => {
  const foodReady = true;

  if (foodReady) {
    resolve("üçï Your pizza is here!");
  } else {
    reject("‚ùå Sorry, kitchen is closed.");
  }
});
```

---

##### üîπ Consuming a Promise

###### Using `.then()` and `.catch()`
```js
orderFood
  .then(result => console.log(result))   // if fulfilled ‚Üí üçï Your pizza is here!
  .catch(error => console.log(error));   // if rejected ‚Üí ‚ùå Sorry, kitchen is closed.
```

###### Using `async/await`
```js
async function eat() {
  try {
    const result = await orderFood;
    console.log(result);
  } catch (err) {
    console.log(err);
  }
}

eat();
```

---