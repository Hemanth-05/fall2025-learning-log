# Date: 2025-09-01

## Topics Covered: Node.js Module Exports: `exports` vs `module.exports`, Path Module, fs Module

### Node.js Module Exports: `exports` vs `module.exports`

Understanding how `exports` and `module.exports` work is one of the most important fundamentals in Node.js. Here we explain their usage, differences, and best practices.

---

#### üîπ How Node.js Modules Work
Every file in Node.js is treated as a **separate module**.  
Behind the scenes, Node wraps your code like this:

```js
(function (exports, require, module, __filename, __dirname) {
  // Your code here
});
```

This means that every file automatically has access to:
- `exports`
- `require`
- `module`
- `__filename`
- `__dirname`

---

#### üîπ The Relationship Between `exports` and `module.exports`
At the start of execution, Node sets things up like this:

```js
let module = { exports: {} };
let exports = module.exports;
```

So:
- **`module.exports`** is the real object that will be returned by `require()`.
- **`exports`** is just a reference to `module.exports`.

---

#### üîπ Correct Usages

##### ‚úÖ Case 1: Adding Multiple Properties
Use `exports.foo` (or `module.exports.foo`) when you want to export **several things**.

```js
// math.js
exports.add = (a, b) => a + b;
exports.subtract = (a, b) => a - b;
exports.multiply = (a, b) => a * b;
exports.divide = (a, b) => a / b;
```

Usage:
```js
const math = require('./math');
console.log(math.add(2, 3)); // 5
console.log(math.divide(6, 2)); // 3
```

Result of `require('./math')`:
```js
{
  add: [Function],
  subtract: [Function],
  multiply: [Function],
  divide: [Function]
}
```

---

##### ‚úÖ Case 2: Exporting a Single Function, Class, or Object
Use `module.exports = ...` when you want to export **just one thing**.

```js
// greet.js
module.exports = function(name) {
  return `Hello, ${name}!`;
};
```

Usage:
```js
const greet = require('./greet');
console.log(greet('Hemanth')); // Hello, Hemanth!
```

Result of `require('./greet')`:
```js
[Function]
```

---

##### ‚ùå Case 3: Overwriting `exports` Directly
Avoid assigning directly to `exports`. This breaks its connection with `module.exports`.

```js
// wrong.js
exports = function(name) {
  return `Hi, ${name}`;
};
```

Usage:
```js
const greet = require('./wrong');
console.log(greet); // {}
```

Result of `require('./wrong')`:
```js
{}
```

---

#### üîπ Rule of Thumb
- If you want **many exports** ‚Üí use `exports.foo = ...`.
- If you want **one single export** ‚Üí use `module.exports = ...`.
- Never do `exports = ...` (it breaks the link).

---

#### üîπ Visual Analogy
Think of `module.exports` as the **box** that Node will return.  
- `exports` is just a shortcut handle pointing to that box.  
- `exports.foo = ...` puts items inside the box.  
- `module.exports = ...` replaces the box entirely.  
- `exports = ...` breaks the handle ‚Üí you‚Äôre pointing at a new box, but Node still returns the old one.

---

#### üîπ Summary Table

| Usage                        | Works? | When to Use |
|-------------------------------|--------|-------------|
| `exports.foo = ...`           | ‚úÖ     | Add multiple properties |
| `module.exports.foo = ...`    | ‚úÖ     | Same as above, explicit |
| `module.exports = ...`        | ‚úÖ     | Replace everything with one export |
| `exports = ...`               | ‚ùå     | Breaks the link, avoid |

---

#### ‚úÖ Best Practice
- Use `exports.foo` (or `module.exports.foo`) for **multiple exports**.  
- Use `module.exports = ...` when the module should expose **just one main thing**.  
- Never overwrite `exports` directly.

### Path Module
 - The path module is purely about string manipulation of file system paths.
 - Most path functions take path strings (not actual files - they don‚Äôt need to exist on disk).

 The Node.js **`path`** module provides utilities for working with file and directory paths.  
Here‚Äôs a detailed explanation of four of its most commonly used methods.

---

#### üîπ 1. `path.dirname(p)`
- **Purpose**: Returns the directory name of a path (everything except the final portion).  
- **Parameter**: `p` ‚Üí a path string.  
- **Returns**: The directory portion of the path.

##### Example:
```js
const path = require('path');

console.log(path.dirname('/users/hemanth/project/app.js'));
// ‚Üí "/users/hemanth/project"
```

---

#### üîπ 2. `path.basename(p, [ext])`
- **Purpose**: Returns the last portion of a path (the file name).  
- **Parameters**:
  - `p` ‚Üí a path string.
  - `ext` *(optional)* ‚Üí if provided, and if the path ends with this extension, it will be removed.  
- **Returns**: File name with or without extension.

##### Example:
```js
const path = require('path');

console.log(path.basename('/users/hemanth/project/app.js'));
// ‚Üí "app.js"

console.log(path.basename('/users/hemanth/project/app.js', '.js'));
// ‚Üí "app"
```

---

#### üîπ 3. `path.extname(p)`
- **Purpose**: Returns the file extension of the path (including the leading dot `.`).  
- **Parameter**: `p` ‚Üí a path string.  
- **Returns**: Extension string or empty string if none.

##### Example:
```js
const path = require('path');

console.log(path.extname('/users/hemanth/project/app.js'));
// ‚Üí ".js"

console.log(path.extname('/users/hemanth/project/readme'));
// ‚Üí ""  (no extension)
```

---

#### üîπ 4. `path.join(...paths)`
- **Purpose**: Joins all given path segments together using the correct platform separator, then normalizes the result.  
- **Parameter**: One or more path strings.  
- **Returns**: Normalized joined path string.

##### Example:
```js
const path = require('path');

console.log(path.join('users', 'hemanth', 'project', 'app.js'));
// ‚Üí "users/hemanth/project/app.js"  (POSIX)

console.log(path.join('/users', 'hemanth', '..', 'guest', 'app.js'));
// ‚Üí "/users/guest/app.js"
```

---

### fs Module

``` js 
const fs = require('fs');
const path = require('path');

// Getting hold of the path
const filePath = path.join(__dirname, 'message.txt');

// Reading a file
try{
    if(fs.existsSync(filePath)){
        const Data = fs.readFileSync(filePath, 'utf8');
        console.log(Data)
    } else{
        console.log("File not found")
    }
} catch(error){
    console.log(error);
}

// Writing to a file
const newFilePath = path.join(__dirname, "messageNew.txt")
const dataToInclude = 'This is the new 430 data that goes into the new file.';
try{
    fs.writeFileSync(newFilePath, dataToInclude)
}catch(error){
    console.log(error)
}

//Appending to a file
try{
    fs.appendFileSync('messageNew.txt', ' data to append');
    console.log('The "data to append" was appended to file!');
}catch(error){
    console.log(error)
}

// Deleting a file
try{
    unlinkSync(filePath)
}catch(error){
    console.log(error);
}
```

In the similar way we can create folders, delete folders.
- fs.mkdirSync(newDirPath);
    The newDirPath can be anything. For eg: newDirPath = path.join(__dirname, "newDir");
- fs.rmdirSync(); - This will delete the folder, but only if the folder is empty, if not then it will throw an error.
- fs.rmSync(path, {recursive: true}); - Will delete the folder even if its not empty.
- fs.renameSync(filePath, newFilePath);

Example for file Rename
``` js
const filePath = path.join(__dirname, "data.txt");
const newFilePath = path.join(__dirname, "newData.txt");

try{
    fs.renameSync(filePath, newFilePath);
}catch(error){
    console.log(error);
}
```

